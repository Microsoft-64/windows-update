<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
      crossorigin="anonymous"
    />
  </head>
  <body class="bg-dark">
    <div class="container">
      <div class="accordion" id="accordionExample">
        <!-- lex program -->
        <div class="accordion-item">
          <h2 class="accordion-header text-center" id="headingTwo">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseTwo"
              aria-expanded="false"
              aria-controls="collapseTwo"
            >
              C program for lexical analysis
            </button>
          </h2>
          <div
            id="collapseTwo"
            class="accordion-collapse collapse"
            aria-labelledby="headingTwo"
            data-bs-parent="#accordionExample"
          >
            <div class="accordion-body">
              <h5>
                  <pre>
int i=0,id=0,kw=0,num=0,op=0,par=0,tot=0,sep=0;


char ch,str[25],new[6]=" \t\n<>\"",oper[]="!#%^&*-+=~|./?",p[6]="}{][)(",s[3]=",;:",head=0;
char keys[34][10] = {"auto", "break", "case", "char", "const", "continue", "default","do", "double", "else", "enum", "extern", "float", "for", "goto",
"if", "int", "long", "main", "return", "short", "signed","sizeof", "static", "struct", "switch", "typedef", "union",
"unsigned", "void", "volatile", "while","main","include"};
int main()
{ 
int j; 
FILE *fp;
fp=fopen("input.txt","r"); 

if(fp==NULL)
{
printf("File not found"); 
return 0;
}

while((ch=fgetc(fp))!=EOF)
{ 
for (j=0;j<=14;j++)
{
if(ch==oper[j]){
str[i]='\0'; iskeyword(str);
printf("%c is an operator\n",ch);
op++; 
tot++;
}

}
for(j=0;j<=5;j++)
{ 
if(ch==p[j])
{
str[i] = '\0'; 
iskeyword(str);
printf("%c is parenthesis\n",ch); par++;
tot++;
}
}

for(j=0;j<=2;j++){ if(ch==s[j])
{
str[i] = '\0'; 
iskeyword(str);
printf("%c is separator\n",ch); 
sep++;
tot++;
}
}

for(j=0;j<=5;j++)
{ 
if(i==-1)
break; 
if(ch==new[j])
{
if(ch=='<')
{
while(ch!='>')
{
if(ch=='<')
{
printf("< is parenthesis\n"); 
par++;
tot++;
}
else printf("%c",ch); 
ch=fgetc(fp);
}

printf(" is a header file\n",ch); 
head++;
tot++;
printf("> is parenthesis\n"); 
par++;
tot++; 
i=-1;
break;
}

if(ch == '"')
{
printf("\""); 
do{
ch=fgetc(fp); 
printf("%c",ch);
} while(ch!='"');
printf( " is an argument\n"); 
tot++;
i=-1;
break;
}
str[i]='\0'; iskeyword(str);
}
}

if(i!=-1){ 
str[i]=ch; 
i++;
}
else
i=0;
}

printf("\nKeywords : %d\nIdentifiers : %d\nSeparator : %d\nOperators : %d\nNumbers : %d\nParenthesis : %d\nHeader files : %d\nTotal : %d",kw,id,sep,op,num,par,head,tot);
return 0; 
getch();
}

void iskeyword(char *p)
{ 
int k,flag=0,j;
for (k=0;k<=33;k++){
if(strcmp(keys[k],p)==0){
printf("%s is a keyword\n",p); 
kw++;
tot++; 
flag=1; 
break;
}
}

if(flag==0){ 
if(isdigit(p[0])){
printf("%s is a number\n",p);
num++;
tot++;
}
else
{
if(p[0]!='\0'){

printf("%s is an identifier\n",p); id++;
tot++;
}
}
}
i=-1;
}
</pre>
              </h5>
            </div>
          </div>
        </div>

        <!-- code generation -->
        <div class="accordion-item">
          <h2 class="accordion-header" id="headingThree">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseThree"
              aria-expanded="false"
              aria-controls="collapseThree"
            >
              Code Generation in C
            </button>
          </h2>
          <div
            id="collapseThree"
            class="accordion-collapse collapse"
            aria-labelledby="headingThree"
            data-bs-parent="#accordionExample"
          >
            <div class="accordion-body">
              <h5>
              <pre>
                <!-- #include<stdio.h>
#include<conio.h>
#include<string.h> -->
char op[2],arg1[5],arg2[5],result[5];
void main()
{
    FILE *fp1,*fp2;
    fp1=fopen("input.txt","r");
    fp2=fopen("output.txt","w");
    while(!feof(fp1))
    {
        fscanf(fp1,"%s%s%s%s",op,arg1,arg2,result);
        if(strcmp(op,"+")==0)
        {
            fprintf(fp2,"\nMOV RO,%s",arg1);
            fprintf(fp2,"\nADD R),%s",arg2);
            fprintf(fp2,"\nMOV %s,RO",result);
        }
        if(strcmp(op,"*")==0)
        {
            fprintf(fp2,"\nMOV RO,%s",arg1);
            fprintf(fp2,"\nMUL RO,%s",arg2);
            fprintf(fp2,"\nMOV %s,RO",result);
            
            
        }
        
        if(strcmp(op,"-")==0)
        {
            fprintf(fp2,"\nMOV RO,%s",arg1);
            fprintf(fp2,"\nSUB RO,%s",arg2);
            fprintf(fp2,"\nMOV %s,RO",result);
            
        }
        if(strcmp(op,"/")==0)
        {
            fprintf(fp2,"\nMOV RO,%s",arg1);
            fprintf(fp2,"\nDIV RO,%s",arg2);
            fprintf(fp2,"\nMOV %s,RO",result);
            
        }
        if(strcmp(op,"=")==0)
        {
            fprintf(fp2,"\nMOV RO,%s",arg1);
            fprintf(fp2,"\nMOV %s,RO",result);
            
        }
    }
    fclose(fp1);
    fclose(fp2);
    getch();
}
</h5>
              </pre>
            </div>
          </div>
        </div>

        <!-- lex program for sentences words  -->
          <div class="accordion-item">
          <h2 class="accordion-header" id="headingFour">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseFour"
              aria-expanded="false"
              aria-controls="collapseFour"
            >
              lex program for count of words,lines,tabs,spaces etc
            </button>
          </h2>
          <div
            id="collapseFour"
            class="accordion-collapse collapse"
            aria-labelledby="headingFour"
            data-bs-parent="#accordionExample"
          >
            <div class="accordion-body">
              <h5><pre>
%option noyywrap
%{
	#include<stdio.h>
	int space=0;
	int tab=0;
	int number=0;
	int sentence=0;
	int word=0;

%}


%%
[' '] {space++;}
[\t] {tab++;}
[A-Za-z]+ {word++;}
[0-9]+ {number++;}
['.']+ {sentence++;}
%%
int main()
{
FILE *ptr;
ptr=fopen("sample.txt","r");
yyin=ptr;
yylex();
printf("\nNumber of Words: %d",word);
printf("\nNumber of Numbers: %d",number);
printf("\nNumber of Spaces: %d",space);
printf("\nNumber of Sentence: %d",sentence);
printf("\nNumber of Tab: %d",tab);
return 0;
}
              </pre></h5>
              </pre>
            </div>
          </div>
        </div>

        <!-- first and follow -->
        <div class="accordion-item">
          <h2 class="accordion-header" id="headingFive">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseFive"
              aria-expanded="false"
              aria-controls="collapseFive"
            >
              First and follow in C
            </button>
          </h2>
          <div
            id="collapseFive"
            class="accordion-collapse collapse"
            aria-labelledby="headingFive"
            data-bs-parent="#accordionExample"
          >
            <div class="accordion-body">
              <h5><pre>
                <!-- #include <stdio.h>
#include <string.h> -->
#define TSIZE 128
int table[100][TSIZE];
char terminal[TSIZE];
char nonterminal[26];
struct product
{
    char str[100];
    int len;
} pro[20];
// no of productions in form A->ß
int no_pro;
char first[26][TSIZE];
char follow[26][TSIZE];
// stores first of each production in form A->ß
char first_rhs[100][TSIZE];
// check if the symbol is nonterminal
int isNT(char c)
{
    return c >= 'A' && c <= 'Z';
}
// reading data from the file
void readFromFile()
{
    FILE *fptr;
    fptr = fopen("input.txt", "r");
    char buffer[255];
    int i;
    int j;
    while (fgets(buffer, sizeof(buffer), fptr))
    {
        printf("%s", buffer);
        j = 0;
        nonterminal[buffer[0] - 'A'] = 1;
        for (i = 0; i < strlen(buffer) - 1; ++i)
        {
            if (buffer[i] == '|')
            {
                ++no_pro;
                pro[no_pro - 1].str[j] = '\0';
                pro[no_pro - 1].len = j;
                pro[no_pro].str[0] = pro[no_pro - 1].str[0];
                pro[no_pro].str[1] = pro[no_pro - 1].str[1];
                pro[no_pro].str[2] = pro[no_pro - 1].str[2];
                j = 3;
            }
            else
            {
                pro[no_pro].str[j] = buffer[i];
                ++j;
                if (!isNT(buffer[i]) && buffer[i] != '-' && buffer[i] != '>')
                {
                    terminal[buffer[i]] = 1;
                }
            }
        }
        pro[no_pro].len = j;
        ++no_pro;
    }
}
void add_FIRST_A_to_FOLLOW_B(char A, char B)
{
    int i;
    for (i = 0; i < TSIZE; ++i)
    {
        if (i != '^')
            follow[B - 'A'][i] = follow[B - 'A'][i] || first[A - 'A'][i];
    }
}
void add_FOLLOW_A_to_FOLLOW_B(char A, char B)
{
    int i;
    for (i = 0; i < TSIZE; ++i)
    {
        if (i != '^')
            follow[B - 'A'][i] = follow[B - 'A'][i] || follow[A - 'A'][i];
    }
}
void FOLLOW()
{
    int t = 0;
    int i, j, k, x;
    while (t++ < no_pro)
    {
        for (k = 0; k < 26; ++k)
        {
            if (!nonterminal[k])
                continue;
            char nt = k + 'A';
            for (i = 0; i < no_pro; ++i)
            {
                for (j = 3; j < pro[i].len; ++j)
                {
                    if (nt == pro[i].str[j])
                    {
                        for (x = j + 1; x < pro[i].len; ++x)
                        {
                            char sc = pro[i].str[x];
                            if (isNT(sc))
                            {
                                add_FIRST_A_to_FOLLOW_B(sc, nt);
                                if (first[sc - 'A']['^'])
                                    continue;
                            }
                            else
                            {
                                follow[nt - 'A'][sc] = 1;
                            }
                            break;
                        }
                        if (x == pro[i].len)
                            add_FOLLOW_A_to_FOLLOW_B(pro[i].str[0], nt);
                    }
                }
            }
        }
    }
}
void add_FIRST_A_to_FIRST_B(char A, char B)
{
    int i;
    for (i = 0; i < TSIZE; ++i)
    {
        if (i != '^')
        {
            first[B - 'A'][i] = first[A - 'A'][i] || first[B - 'A'][i];
        }
    }
}
void FIRST()
{
    int i, j;
    int t = 0;
    while (t < no_pro)
    {
        for (i = 0; i < no_pro; ++i)
        {
            for (j = 3; j < pro[i].len; ++j)
            {
                char sc = pro[i].str[j];
                if (isNT(sc))
                {
                    add_FIRST_A_to_FIRST_B(sc, pro[i].str[0]);
                    if (first[sc - 'A']['^'])
                        continue;
                }
                else
                {
                    first[pro[i].str[0] - 'A'][sc] = 1;
                }
                break;
            }
            if (j == pro[i].len)
                first[pro[i].str[0] - 'A']['^'] = 1;
        }
        ++t;
    }
}
void add_FIRST_A_to_FIRST_RHS__B(char A, int B)
{
    int i;
    for (i = 0; i < TSIZE; ++i)
    {
        if (i != '^')
            first_rhs[B][i] = first[A - 'A'][i] || first_rhs[B][i];
    }
}
// Calculates FIRST(ß) for each A->ß
void FIRST_RHS()
{
    int i, j;
    int t = 0;
    while (t < no_pro)
    {
        for (i = 0; i < no_pro; ++i)
        {
            for (j = 3; j < pro[i].len; ++j)
            {
                char sc = pro[i].str[j];
                if (isNT(sc))
                {
                    add_FIRST_A_to_FIRST_RHS__B(sc, i);
                    if (first[sc - 'A']['^'])
                        continue;
                }
                else
                {
                    first_rhs[i][sc] = 1;
                }
                break;
            }
            if (j == pro[i].len)
                first_rhs[i]['^'] = 1;
        }
        ++t;
    }
}
int main(int argc, char *argv[])
{
    readFromFile();
    follow[pro[0].str[0] - 'A']['$'] = 1;
    FIRST();
    FOLLOW();
    FIRST_RHS();
    int i, j, k;

    // display first of each variable
    printf("\n");
    for (i = 0; i < no_pro; ++i)
    {
        if (i == 0 || (pro[i - 1].str[0] != pro[i].str[0]))
        {
            char c = pro[i].str[0];
            printf("FIRST OF %c: ", c);
            for (j = 0; j < TSIZE; ++j)
            {
                if (first[c - 'A'][j])
                {
                    printf("%c ", j);
                }
            }
            printf("\n");
        }
    }

    // display follow of each variable
    printf("\n");
    for (i = 0; i < no_pro; ++i)
    {
        if (i == 0 || (pro[i - 1].str[0] != pro[i].str[0]))
        {
            char c = pro[i].str[0];
            printf("FOLLOW OF %c: ", c);
            for (j = 0; j < TSIZE; ++j)
            {
                if (follow[c - 'A'][j])
                {
                    printf("%c ", j);
                }
            }
            printf("\n");
        }
    }
    // display first of each variable ß
    // in form A->ß
    printf("\n");

    // the parse table contains '$'
    // set terminal['$'] = 1
    // to include '$' in the parse table
    terminal['$'] = 1;

    // the parse table do not read '^'
    // as input
    // so we set terminal['^'] = 0
    // to remove '^' from terminals
    terminal['^'] = 0;
}
              </pre></h5>
              </pre>
            </div>
          </div>
        </div>

        <!-- ICG in java -->
        <div class="accordion-item">
          <h2 class="accordion-header" id="headingSixth">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseSixth"
              aria-expanded="false"
              aria-controls="collapseSixth"
            >
              ICG in Java
            </button>
          </h2>
          <div
            id="collapseSixth"
            class="accordion-collapse collapse"
            aria-labelledby="headingSixth"
            data-bs-parent="#accordionExample"
          >
            <div class="accordion-body">
              <h5><pre>
package Demo;

import java.util.*;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

		public class Assembly{
		   
		    public static void main(String[] args) throws IOException {

		        FileWriter fw = null;
		        BufferedWriter bw = null;
		        PrintWriter pw = null;

		        try {
		            fw = new FileWriter("ICG1.txt", true);
		            bw = new BufferedWriter(fw);
		            pw = new PrintWriter(bw);

		     Scanner sc =new Scanner(System.in);
		     System.out.println("Enter the expression:");
		     String a = sc.next();

		     String s = null;
		     int x = 0;
		     pw.println("\nop\targ1\targ2\tres\n");

		for(int i = 0; i < a.length(); i++)
		     {
		        if (a.charAt(i) == '=' && a.charAt(i+1)=='-' )
		        {
		            pw.println('-'+"\t"+a.charAt(i+2)+"\t-"+"\tU");
		            char s3 = a.charAt(i+1);
		            char s4 = a.charAt(i+2);
		            s = String.valueOf(s3)+String.valueOf(s4);
		            a=a.replace(s,"U");
		        }
		     }
		for(int i = 0; i < a.length(); i++)
		     {
		         char c = a.charAt(i);
		        try {
		         if (c == '/' && a.charAt(i+1)=='-' && a.charAt(i+2)=='t' && Character.isDigit(a.charAt(i+3))==true ){
		            pw.println('-'+"\t"+'t'+a.charAt(i+3)+"\t-"+"\tU");
		             char s3 = a.charAt(i+1);
		             char s4 = a.charAt(i+2);
		             char s5 = a.charAt(i+3);
		             s = String.valueOf(s3)+String.valueOf(s4)+String.valueOf(s5);
		             a=a.replace(s,"U");
		             
		         }

		         if(c == '/' && a.charAt(i+1)=='-' && a.charAt(i+2)!='t' && Character.isDigit(a.charAt(i+3))==false){
		            pw.println('-'+"\t"+a.charAt(i+2)+"\t-"+"\tU");
		             char s3 = a.charAt(i+1);
		             char s4 = a.charAt(i+2);
		             s = String.valueOf(s3)+String.valueOf(s4);
		             a=a.replace(s,"U");
		             
		         }
		        }
		        catch(Exception e1){}


		         if (c == '/')
		         {
		         char st=a.charAt(i-1);
		            if(a.charAt(i-2)=='t' && Character.isDigit(st)==true  && a.charAt(i+1)=='t' && Character.isDigit(i+1)==true){
		                if(Character.isDigit(a.charAt(i+2))==true)
		                    pw.println(c+"\t"+a.charAt(i-2)+a.charAt(i-1)+"\t"+a.charAt(i+1)+a.charAt(i+2)+"\tt"+x);

		             char s0 = a.charAt(i-2);
		             char s1 = a.charAt(i-1);
		             char s2 = a.charAt(i);
		             char s3 = a.charAt(i+1);
		             char s4 = a.charAt(i+2);
		                
		             s = String.valueOf(s0)+String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3)+String.valueOf(s4);
		             a=a.replace(s,"t"+x);
		             x++;
		            }

		            else if(a.charAt(i-2)=='t' && Character.isDigit(st)==true && a.charAt(i+1)!='t' ){
		                pw.println(c+"\t"+a.charAt(i-2)+a.charAt(i-1)+"\t"+a.charAt(i+1)+"\tt"+x);
		                char s0 = a.charAt(i-2);
		                char s1 = a.charAt(i-1);
		                char s2 = a.charAt(i);
		                char s3 = a.charAt(i+1);
		                s = String.valueOf(s0)+String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3);
		                a=a.replace(s,"t"+x);
		                x++;
		            }

		            else if(a.charAt(i+1)=='t' && Character.isDigit(a.charAt(i+2))==true && a.charAt(i-2)!='t' && Character.isDigit(st)==false ){
		                pw.println(c+"\t"+a.charAt(i-1)+"\t"+a.charAt(i+1)+a.charAt(i+2)+"\tt"+x);
		                char s1 = a.charAt(i-1);
		                char s2 = a.charAt(i);
		                char s3 = a.charAt(i+1);
		                char s4 = a.charAt(i+2);
		                s = String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3)+String.valueOf(s4);
		                a=a.replace(s,"t"+x);
		                x++;
		            }

		            else{
		             pw.println(c+"\t"+a.charAt(i-1)+"\t"+a.charAt(i+1)+"\tt"+x);
		             char s1 = a.charAt(i-1);
		             char s2 = a.charAt(i);
		             char s3 = a.charAt(i+1);
		             s = String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3);
		             a=a.replace(s,"t"+x);
		             x++;
		            }		            
		         
		        }
		     }
		     
		for(int i = 0; i < a.length(); i++)
		     {
		         char c = a.charAt(i);




		         try {
		            if (c == '*' && a.charAt(i+1)=='-' && a.charAt(i+2)=='t' && Character.isDigit(a.charAt(i+3))==true ){
		               pw.println('-'+"\t"+'t'+a.charAt(i+3)+"\t-"+"\tU");
		                char s3 = a.charAt(i+1);
		                char s4 = a.charAt(i+2);
		                char s5 = a.charAt(i+3);
		                s = String.valueOf(s3)+String.valueOf(s4)+String.valueOf(s5);
		                a=a.replace(s,"U");
		                //pw.println(a);
		            }
		   
		            if(c == '*' && a.charAt(i+1)=='-' && a.charAt(i+2)!='t' && Character.isDigit(a.charAt(i+3))==false){
		               pw.println('-'+"\t"+a.charAt(i+2)+"\t-"+"\tU");
		                char s3 = a.charAt(i+1);
		                char s4 = a.charAt(i+2);
		                s = String.valueOf(s3)+String.valueOf(s4);
		                a=a.replace(s,"U");
		                //pw.println(a);
		            }
		           }
		           catch(Exception e1){}
		   


		         if (c == '*')
		         {
		            char st=a.charAt(i-1);
		            if(a.charAt(i-2)=='t' && Character.isDigit(st)==true  && a.charAt(i+1)=='t' ){
		                if(Character.isDigit(a.charAt(i+2))==true)
		                    pw.println(c+"\t"+a.charAt(i-2)+a.charAt(i-1)+"\t"+a.charAt(i+1)+a.charAt(i+2)+"\tt"+x);

		             char s0 = a.charAt(i-2);
		             char s1 = a.charAt(i-1);
		             char s2 = a.charAt(i);
		             char s3 = a.charAt(i+1);
		             char s4 = a.charAt(i+2);
		                
		             s = String.valueOf(s0)+String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3)+String.valueOf(s4);
		             a=a.replace(s,"t"+x);
		             x++;
		            }

		            else if(a.charAt(i-2)=='t' && Character.isDigit(st)==true && a.charAt(i+1)!='t' ){
		                pw.println(c+"\t"+a.charAt(i-2)+a.charAt(i-1)+"\t"+a.charAt(i+1)+"\tt"+x);
		                char s0 = a.charAt(i-2);
		                char s1 = a.charAt(i-1);
		                char s2 = a.charAt(i);
		                char s3 = a.charAt(i+1);
		                s = String.valueOf(s0)+String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3);
		                a=a.replace(s,"t"+x);
		                x++;
		            }

		            else if(a.charAt(i+1)=='t' && Character.isDigit(a.charAt(i+2))==true && a.charAt(i-2)!='t' && Character.isDigit(st)==false ){
		                pw.println(c+"\t"+a.charAt(i-1)+"\t"+a.charAt(i+1)+a.charAt(i+2)+"\tt"+x);
		                char s1 = a.charAt(i-1);
		                char s2 = a.charAt(i);
		                char s3 = a.charAt(i+1);
		                char s4 = a.charAt(i+2);
		                s = String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3)+String.valueOf(s4);
		                a=a.replace(s,"t"+x);
		                x++;
		            }

		            else{
		             pw.println(c+"\t"+a.charAt(i-1)+"\t"+a.charAt(i+1)+"\tt"+x);
		             char s1 = a.charAt(i-1);
		             char s2 = a.charAt(i);
		             char s3 = a.charAt(i+1);
		             s = String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3);
		             a=a.replace(s,"t"+x);
		             x++;
		            }
		            
		         }
		         
		     }
		     
		for(int i = 0; i < a.length(); i++)
		     {
		         char c = a.charAt(i);

		         
		         try {
		            if (c == '+' && a.charAt(i+1)=='-' && a.charAt(i+2)=='t' && Character.isDigit(a.charAt(i+3))==true ){
		               pw.println('-'+"\t"+'t'+a.charAt(i+3)+"\t-"+"\tU");
		                char s3 = a.charAt(i+1);
		                char s4 = a.charAt(i+2);
		                char s5 = a.charAt(i+3);
		                s = String.valueOf(s3)+String.valueOf(s4)+String.valueOf(s5);
		                a=a.replace(s,"U");
		                
		               
		            }
		   
		            if(c == '+' && a.charAt(i+1)=='-' && a.charAt(i+2)!='t' && Character.isDigit(a.charAt(i+3))==false){
		               pw.println('-'+"\t"+a.charAt(i+2)+"\t-"+"\tU");
		                char s3 = a.charAt(i+1);
		                char s4 = a.charAt(i+2);
		                s = String.valueOf(s3)+String.valueOf(s4);
		                a=a.replace(s,"U");
		                
		                
		            }
		           }
		           catch(Exception e1){}
		   



		         if (c == '+')
		         {
		            char st=a.charAt(i-1);
		            if(a.charAt(i-2)=='t' && Character.isDigit(st)==true  && a.charAt(i+1)=='t' ){
		                if(Character.isDigit(a.charAt(i+2))==true)
		                    pw.println(c+"\t"+a.charAt(i-2)+a.charAt(i-1)+"\t"+a.charAt(i+1)+a.charAt(i+2)+"\tt"+x);

		             char s0 = a.charAt(i-2);
		             char s1 = a.charAt(i-1);
		             char s2 = a.charAt(i);
		             char s3 = a.charAt(i+1);
		             char s4 = a.charAt(i+2);
		                
		             s = String.valueOf(s0)+String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3)+String.valueOf(s4);
		             a=a.replace(s,"t"+x);
		             x++;
		             i=2;
		            }

		            else if(a.charAt(i-2)=='t' && Character.isDigit(st)==true && a.charAt(i+1)!='t' ){
		                pw.println(c+"\t"+a.charAt(i-2)+a.charAt(i-1)+"\t"+a.charAt(i+1)+"\tt"+x);
		                char s0 = a.charAt(i-2);
		                char s1 = a.charAt(i-1);
		                char s2 = a.charAt(i);
		                char s3 = a.charAt(i+1);
		                s = String.valueOf(s0)+String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3);
		                a=a.replace(s,"t"+x);
		                x++;
		                i=2;
		            }

		            else if(a.charAt(i+1)=='t' && Character.isDigit(a.charAt(i+2))==true && a.charAt(i-2)!='t' && Character.isDigit(st)==false ){
		                pw.println(c+"\t"+a.charAt(i-1)+"\t"+a.charAt(i+1)+a.charAt(i+2)+"\tt"+x);
		                char s1 = a.charAt(i-1);
		                char s2 = a.charAt(i);
		                char s3 = a.charAt(i+1);
		                char s4 = a.charAt(i+2);
		                s = String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3)+String.valueOf(s4);
		                a=a.replace(s,"t"+x);
		                x++;
		                i=2;
		            }

		            else{
		             pw.println(c+"\t"+a.charAt(i-1)+"\t"+a.charAt(i+1)+"\tt"+x);
		             char s1 = a.charAt(i-1);
		             char s2 = a.charAt(i);
		             char s3 = a.charAt(i+1);
		             s = String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3);
		             a=a.replace(s,"t"+x);
		             x++;
		             i=2;
		            }
		            
		             
		         }
		         
		     }
		     
		for(int i = 0; i < a.length(); i++)
		     {
		         char c = a.charAt(i);


		         

		         try {
		            if (c == '-' && a.charAt(i+1)=='-' && a.charAt(i+2)=='t' && Character.isDigit(a.charAt(i+3))==true ){
		               pw.println('-'+"\t"+'t'+a.charAt(i+3)+"\t-"+"\tU");
		                char s3 = a.charAt(i+1);
		                char s4 = a.charAt(i+2);
		                char s5 = a.charAt(i+3);
		                s = String.valueOf(s3)+String.valueOf(s4)+String.valueOf(s5);
		                a=a.replace(s,"U");
		                
		            }
		   
		            if(c == '-' && a.charAt(i+1)=='-' && a.charAt(i+2)!='t' && Character.isDigit(a.charAt(i+3))==false){
		               pw.println('-'+"\t"+a.charAt(i+2)+"\t-"+"\tU");
		                char s3 = a.charAt(i+1);
		                char s4 = a.charAt(i+2);
		                s = String.valueOf(s3)+String.valueOf(s4);
		                a=a.replace(s,"U");
		                
		            }
		           }
		           catch(Exception e1){}
		   


		         if (c == '-')
		         {
		            char st=a.charAt(i-1);
		            if(a.charAt(i-2)=='t' && Character.isDigit(st)==true  && a.charAt(i+1)=='t' ){
		                if(Character.isDigit(a.charAt(i+2))==true)
		                    pw.println(c+"\t"+a.charAt(i-2)+a.charAt(i-1)+"\t"+a.charAt(i+1)+a.charAt(i+2)+"\tt"+x);

		             char s0 = a.charAt(i-2);
		             char s1 = a.charAt(i-1);
		             char s2 = a.charAt(i);
		             char s3 = a.charAt(i+1);
		             char s4 = a.charAt(i+2);
		                
		             s = String.valueOf(s0)+String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3)+String.valueOf(s4);
		             a=a.replace(s,"t"+x);
		             x++;
		            }

		            else if(a.charAt(i-2)=='t' && Character.isDigit(st)==true && a.charAt(i+1)!='t' ){
		                pw.println(c+"\t"+a.charAt(i-2)+a.charAt(i-1)+"\t"+a.charAt(i+1)+"\tt"+x);
		                char s0 = a.charAt(i-2);
		                char s1 = a.charAt(i-1);
		                char s2 = a.charAt(i);
		                char s3 = a.charAt(i+1);
		                s = String.valueOf(s0)+String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3);
		                a=a.replace(s,"t"+x);
		                x++;
		            }

		            else if(a.charAt(i+1)=='t' && Character.isDigit(a.charAt(i+2))==true && a.charAt(i-2)!='t' && Character.isDigit(st)==false ){
		                pw.println(c+"\t"+a.charAt(i-1)+"\t"+a.charAt(i+1)+a.charAt(i+2)+"\tt"+x);
		                char s1 = a.charAt(i-1);
		                char s2 = a.charAt(i);
		                char s3 = a.charAt(i+1);
		                char s4 = a.charAt(i+2);
		                s = String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3)+String.valueOf(s4);
		                a=a.replace(s,"t"+x);
		                x++;
		            }

		            else{
		             pw.println(c+"\t"+a.charAt(i-1)+"\t"+a.charAt(i+1)+"\tt"+x);
		             char s1 = a.charAt(i-1);
		             char s2 = a.charAt(i);
		             char s3 = a.charAt(i+1);
		             s = String.valueOf(s1)+String.valueOf(s2)+String.valueOf(s3);
		             a=a.replace(s,"t"+x);
		             x++;
		            }
		            
		         }   
		     }

		    if (a.charAt(1) == '='){
		        pw.println('='+"\t"+a.charAt(0)+"\t"+"-\t"+a.charAt(2)+a.charAt(3));

		     }

		     pw.flush();

		        } finally {
		            try {
		                pw.close();
		                bw.close();
		                fw.close();
		            } catch (IOException io) { 
		            }

		        }
		    	       
		}		
	}
              </pre></h5>
              </pre>
            </div>
          </div>
        </div>


        <!-- parsing table -->
        <div class="accordion-item">
          <h2 class="accordion-header" id="headingSeventh">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseSeventh"
              aria-expanded="false"
              aria-controls="collapseSeventh"
            >
              Parsing Table for predective parser
            </button>
          </h2>
          <div
            id="collapseSeventh"
            class="accordion-collapse collapse"
            aria-labelledby="headingSeventh"
            data-bs-parent="#accordionExample"
          >
            <div class="accordion-body">
              <h5>
                <pre>
#include<stdio.h>
#include<string.h>
#define TSIZE 128
int table[100][TSIZE];
char terminal[TSIZE];
char nonterminal[26];
struct product {
    char str[100];
    int len;
}pro[20];
// no of productions in form A->ß
int no_pro;
char first[26][TSIZE];
char follow[26][TSIZE];
// stores first of each production in form A->ß
char first_rhs[100][TSIZE];
// check if the symbol is nonterminal
int isNT(char c) {
    return c >= 'A' && c <= 'Z';
}
// reading data from the file
void readFromFile() {
    FILE* fptr;
    fptr = fopen("text.txt", "r");
    char buffer[255];
    int i;
    int j;
    while (fgets(buffer, sizeof(buffer), fptr)) {
        printf("%s", buffer);
        j = 0;
        nonterminal[buffer[0] - 'A'] = 1;
        for (i = 0; i < strlen(buffer) - 1; ++i) {
            if (buffer[i] == '|') {
                ++no_pro;
                pro[no_pro - 1].str[j] = '\0';
                pro[no_pro - 1].len = j;
                pro[no_pro].str[0] = pro[no_pro - 1].str[0];
                pro[no_pro].str[1] = pro[no_pro - 1].str[1];
                pro[no_pro].str[2] = pro[no_pro - 1].str[2];
                j = 3;
            }
            else {
                pro[no_pro].str[j] = buffer[i];
                ++j;
                if (!isNT(buffer[i]) && buffer[i] != '-' && buffer[i] != '>') {
                    terminal[buffer[i]] = 1;
                }
            }
        }
        pro[no_pro].len = j;
        ++no_pro;
    }
}
void add_FIRST_A_to_FOLLOW_B(char A, char B) {
    int i;
    for (i = 0; i < TSIZE; ++i) {
        if (i != '^')
            follow[B - 'A'][i] = follow[B - 'A'][i] || first[A - 'A'][i];
    }
}
void add_FOLLOW_A_to_FOLLOW_B(char A, char B) {
    int i;
    for (i = 0; i < TSIZE; ++i) {
        if (i != '^')
            follow[B - 'A'][i] = follow[B - 'A'][i] || follow[A - 'A'][i];
    }
}
void FOLLOW() {
    int t = 0;
    int i, j, k, x;
    while (t++ < no_pro) {
        for (k = 0; k < 26; ++k) {
            if (!nonterminal[k])    continue;
            char nt = k + 'A';
            for (i = 0; i < no_pro; ++i) {
                for (j = 3; j < pro[i].len; ++j) {
                    if (nt == pro[i].str[j]) {
                        for (x = j + 1; x < pro[i].len; ++x) {
                            char sc = pro[i].str[x];
                            if (isNT(sc)) {
                                add_FIRST_A_to_FOLLOW_B(sc, nt);
                                if (first[sc - 'A']['^'])
                                    continue;
                            }
                            else {
                                follow[nt - 'A'][sc] = 1;
                            }
                            break;
                        }
                        if (x == pro[i].len)
                            add_FOLLOW_A_to_FOLLOW_B(pro[i].str[0], nt);
                    }
                }
            }
        }
    }
}
void add_FIRST_A_to_FIRST_B(char A, char B) {
    int i;
    for (i = 0; i < TSIZE; ++i) {
        if (i != '^') {
            first[B - 'A'][i] = first[A - 'A'][i] || first[B - 'A'][i];
        }
    }
}
void FIRST() {
    int i, j;
    int t = 0;
    while (t < no_pro) {
        for (i = 0; i < no_pro; ++i) {
            for (j = 3; j < pro[i].len; ++j) {
                char sc = pro[i].str[j];
                if (isNT(sc)) {
                    add_FIRST_A_to_FIRST_B(sc, pro[i].str[0]);
                    if (first[sc - 'A']['^'])
                        continue;
                }
                else {
                    first[pro[i].str[0] - 'A'][sc] = 1;
                }
                break;
            }
            if (j == pro[i].len)
                first[pro[i].str[0] - 'A']['^'] = 1;
        }
        ++t;
    }
}
void add_FIRST_A_to_FIRST_RHS__B(char A, int B) {
    int i;
    for (i = 0; i < TSIZE; ++i) {
        if (i != '^')
            first_rhs[B][i] = first[A - 'A'][i] || first_rhs[B][i];
    }
}
// Calculates FIRST(ß) for each A->ß
void FIRST_RHS() {
    int i, j;
    int t = 0;
    while (t < no_pro) {
        for (i = 0; i < no_pro; ++i) {
            for (j = 3; j < pro[i].len; ++j) {
                char sc = pro[i].str[j];
                if (isNT(sc)) {
                    add_FIRST_A_to_FIRST_RHS__B(sc, i);
                    if (first[sc - 'A']['^'])
                        continue;
                }
                else {
                    first_rhs[i][sc] = 1;
                }
                break;
            }
            if (j == pro[i].len)
                first_rhs[i]['^'] = 1;
        }
        ++t;
    }
}
int main(int argc, char *argv[]) {
    readFromFile();
    follow[pro[0].str[0] - 'A']['$'] = 1;
    FIRST();
    FOLLOW();
    FIRST_RHS();
    int i, j, k;
 
    terminal['$'] = 1;
    
    // the parse table do not read '^'
    // as input
    // so we set terminal['^'] = 0
    // to remove '^' from terminals
    terminal['^'] = 0;
    
    // printing parse table
    printf("\n");
    printf("\n\t**************** LL(1) PARSING TABLE *******************\n");
    printf("\t--------------------------------------------------------\n");
    printf("%-10s", "");
    for (i = 0; i < TSIZE; ++i) {
        if (terminal[i])    printf("%-10c", i);
    }
    printf("\n");
    int p = 0;
    for (i = 0; i < no_pro; ++i) {
        if (i != 0 && (pro[i].str[0] != pro[i - 1].str[0]))
            p = p + 1;
        for (j = 0; j < TSIZE; ++j) {
            if (first_rhs[i][j] && j != '^') {
                table[p][j] = i + 1;
            }
            else if (first_rhs[i]['^']) {
                for (k = 0; k < TSIZE; ++k) {
                    if (follow[pro[i].str[0] - 'A'][k]) {
                        table[p][k] = i + 1;
                    }
                }
            }
        }
    }
    k = 0;
    for (i = 0; i < no_pro; ++i) {
        if (i == 0 || (pro[i - 1].str[0] != pro[i].str[0])) {
            printf("%-10c", pro[i].str[0]);
            for (j = 0; j < TSIZE; ++j) {
                if (table[k][j]) {
                    printf("%-10s", pro[table[k][j] - 1].str);
                }
                else if (terminal[j]) {
                    printf("%-10s", "");
                }
            }
            ++k;
            printf("\n");
        }
    }
}
                </pre>
              </h5>
              </pre>
            </div>
          </div>
        </div>

        <!-- lex for arithmetic expression -->
        <div class="accordion-item">
          <h2 class="accordion-header" id="headingSeventh">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseSeventh"
              aria-expanded="false"
              aria-controls="collapseSeventh"
            >
              Lex for arithmetic expression
            </button>
          </h2>
          <div
            id="collapseSeventh"
            class="accordion-collapse collapse"
            aria-labelledby="headingSeventh"
            data-bs-parent="#accordionExample"
          >
            <div class="accordion-body">
             <h5>
               <pre>
%option noyywrap
%{
	#include<stdio.h>
%}

digit [0-9]
alphabet [a-zA-Z]
id {alphabet}({alphabet}|{digit})*
op [-|+|*|/|%|=|^]

%%
"import"|"from"|"def"|"class"|"print"|"for"|"while"|"if"|"else"|"elif"|"return" 
{printf("\n KEYWORD = %s",yytext);}
:            {printf("\n COLON -> %s", yytext);}
{id}         {printf("\n IDENTIFIER -> %s", yytext);}
{op}+        {printf("\n OPERATOR -> %s", yytext);}
{digit}+     {printf("\n NUMBER -> %d", atoi(yytext));}
[{}]|[()]    {printf("\n BRACKETS -> %s", yytext);}
,            {printf("\n COMMA -> %s", yytext);}
%%

int main()
{
extern FILE *yyin;
yyin=fopen("sample.txt","r");
printf("%s",yyin);
yylex();		
return 0;
               </pre>
             </h5>
            </div>
          </div>
        </div>

        <!-- Parse string id=id*id -->
        <div class="accordion-item">
          <h2 class="accordion-header" id="headingEight">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseEight"
              aria-expanded="false"
              aria-controls="collapseEight"
            >
              Parse string id+id*id for predctive parser
            </button>
          </h2>
          <div
            id="collapseEight"
            class="accordion-collapse collapse"
            aria-labelledby="headingEight"
            data-bs-parent="#accordionExample"
          >
            <div class="accordion-body">
             <h5>
               <pre>
<!-- #include <stdio.h>
#include <stdlib.h>
#include <string.h> -->

int noT, noNT;
char STK[20];
int TOP = -1;
typedef struct rule {
  char lhs;
  char rhs[10];
  int num;
} rule;
struct rule rules[15];
typedef struct frst {
  char c;
  char set[30];
  int len;
} frst;
struct frst firsts[10];
typedef struct follow {
  char c;
  char set[30];
  int len;
  int visited;
} follow;
struct follow follows[10];
int isNonTerminal(char c, int noRules) {
  int i = 0;
  for (i; i < noRules; i++)
    if (rules[i].lhs == c)
      return 1;
  return 0;
}
void push(char c) { STK[++TOP] = c; }
void pop() { STK[TOP--] = '\0'; }
void printStack() {
  int i;
  printf("\nTOP=%d\n", TOP);
  for (i = 0; i < 20; i++) {
    if (STK[i] == '\0')
      break;
    printf("%c", STK[i]);
  }
}
int inarr(char *arr, char c, int noRules) {
  int i;
  for (i = 0; i < noRules; i++)
    if (arr[i] == c)
      return 1;
  return 0;
}
int isInFirSet(char NT, char ch, int noNT) {
  int i = 0;
  int j = 0;
  for (i = 0; i < noNT; i++)
    if (firsts[i].c == NT)
      break;
  for (j = 0; j <= firsts[i].len; j++)
    if (firsts[i].set[j] == ch)
      return 1;

  return 0;
}
int isInFolSet(char NT, char ch, int noNT) {
  int i = 0;
  int j = 0;
  for (i = 0; i < noNT; i++)
    if (follows[i].c == NT)
      break;
  for (j = 0; j <= follows[i].len; j++)
    if (follows[i].set[j] == ch)
      return 1;

  return 0;
}

void copyfirst(char NT1, char NT2, int noNT) {
  int i, j;
  char ch;
  for (i = 0; i < noNT; i++)
    if (firsts[i].c == NT1)
      break;
  for (j = 0; j < noNT; j++)
    if (firsts[j].c == NT2)
      break;
  int ind;
  int k;
  for (k = 0; k < firsts[j].len; k++) {
    ind = firsts[i].len;
    ch = firsts[j].set[k];
    if (!isInFirSet(NT1, ch, noNT) && ch != 'e') {
      firsts[i].set[ind] = ch;
      firsts[i].len++;
    }
  }
}
void copyfollow(char NT1, char NT2, int noNT) {
  printf("\n");
  int i, j;
  char ch;
  for (i = 0; i < noNT; i++)
    if (follows[i].c == NT1)
      break;
  for (j = 0; j < noNT; j++)
    if (follows[j].c == NT2)
      break;
  int ind;
  int k;
  for (k = 0; k < follows[j].len; k++) {
    ind = follows[i].len;
    ch = follows[j].set[k];
    if (!isInFolSet(NT1, ch, noNT) && ch != 'e') {
      follows[i].set[ind] = ch;
      follows[i].len++;
    }
  }
}
void copyfollowfirst(char NT1, char NT2, int noNT) {
  int i, j;
  char ch;
  for (i = 0; i < noNT; i++)
    if (follows[i].c == NT1)
      break;
  for (j = 0; j < noNT; j++)
    if (firsts[j].c == NT2)
      break;
  int ind;
  int k;
  for (k = 0; k < firsts[j].len; k++) {
    ind = follows[i].len;
    ch = firsts[j].set[k];
    if (!isInFolSet(NT1, ch, noNT) && ch != 'e') {
      follows[i].set[ind] = ch;
      follows[i].len++;
    }
  }
}

void copyfollowfollow(char NT1, char NT2, int noNT) {
  int i, j;
  char ch;
  for (i = 0; i < noNT; i++)
    if (follows[i].c == NT1)
      break;
  for (j = 0; j < noNT; j++)
    if (follows[j].c == NT2)
      break;
  int ind;
  int k;
  for (k = 0; k < follows[j].len; k++) {
    ind = follows[i].len;
    ch = follows[j].set[k];
    if (!isInFolSet(NT1, ch, noNT) && ch != 'e') {
      follows[i].set[ind] = ch;
      follows[i].len++;
    }
  }
}

void add2first(char NT1, int noRules, int noNT, int rhslen, int ruleno) {
  rhslen = rhslen + 1;
  // printf("\nNT=%c,ruleno=%d,rhslen=%d\t",NT1,ruleno,rhslen);
  int i = 0, k = 0;
  int j, index;
  char NT2;
  for (k = 0; k < rhslen;) {
    char NT2 = rules[ruleno].rhs[k];
    if (!isNonTerminal(NT2, noRules)) {
      // add that terminal to NT1
      for (j = 0; j < noNT; j++)
        if (firsts[j].c == NT1)
          break;
      if (!isInFirSet(NT1, NT2, noNT)) {
        index = firsts[j].len;
        firsts[j].set[index] = NT2;
        firsts[j].len++;
        return;
      }
      // printf("\n");
    } else if (isNonTerminal(NT2, noRules)) {
      int temp = 0;
      for (j = 0; j < noRules; j++) {
        if ((rules[j].lhs == NT2) && isNonTerminal(rules[j].rhs[0], noRules)) {
          temp = 1;
          // printf("\n%c\t%s",rules[j].lhs,rules[j].rhs);
          add2first(NT2, noRules, noNT, rules[j].num, j);
          copyfirst(NT1, NT2, noRules);
        }
      }
      if (temp == 0) {
        copyfirst(NT1, NT2, noRules);
      }
      // printf("\n");
    }
    if ((k == rhslen - 1) && isInFirSet(NT2, 'e', noNT)) {
      // printf("\nk=%d,NT1=%c,NT2=%c\n",k,NT1,NT2);
      int m;
      int index;
      for (m = 0; m < noNT; m++)
        if (firsts[m].c == NT1)
          break;
      if (!isInFirSet(NT1, 'e', noNT)) {
        index = firsts[m].len;
        firsts[m].set[index] = 'e';
        firsts[m].len++;
      }
      return;
    } else if (isInFirSet(NT2, 'e', noNT) &&
               (isNonTerminal(NT2, noRules))) { // printf("JJJJJ\n");
      k++;
    } else { // printf("MMMMM\n");
      return;
    }
  }
  // printf("\n");
}
void add2follow(char ch, char NT1, int noNT) {
  int j, index;
  for (j = 0; j < noNT; j++)
    if (follows[j].c == NT1)
      break;
  if (!isInFolSet(NT1, ch, noNT)) {
    index = follows[j].len;
    follows[j].set[index] = ch;
    follows[j].len++;
  }
}

int charIndexT(char c, char *term, int noT) {
  int i;
  if (c == '\0')
    return -1;
  for (i = 0; i < noT; i++) {
    if (c == term[i])
      return i;
  }
  return -1;
}
int charIndexNT(char c, char *nonTerm, int noNT) {
  int i;
  if (c == '\0')
    return -1;
  for (i = 0; i < noNT; i++) {
    if (c == nonTerm[i])
      return i;
  }
}
void printTable(int TABLE[noNT][noT], char *term, char *nonTerm) {
  printf("\nParsing Table\n\n");
  int i, j;
  for (i = 0; i < noT; i++)
    printf("\t%c", term[i]);
  printf("\n");
  for (i = 0; i < noNT; i++) {
    printf("%c\t", nonTerm[i]);
    for (j = 0; j < noT; j++)
      printf("%d\t", TABLE[i][j]);
    printf("\n");
  }
}

void findfollow(int NT1, int noRules, int noNT) {
  int i, j, k, x, m;
  for (i = 0; i < noNT; i++)
    if (follows[i].c == NT1) {
      if (follows[i].visited == 1) {
        return;
      } else {
        follows[i].visited = 1;
        break;
      }
    }
  for (j = 0; j < noRules; j++) {
    char next;
    for (k = 0; k <= rules[j].num; k++) {
      if (k == rules[j].num) {
        if (rules[j].rhs[k] == NT1) {
          findfollow(rules[j].lhs, noRules, noNT);
          copyfollowfollow(NT1, rules[j].lhs, noNT);
        }
      } else if (rules[j].rhs[k] == NT1) {
        x = k;
        next = rules[j].rhs[++x];
        while (x < (rules[j].num + 1)) {
          int temp;
          if (!isNonTerminal(next, noRules)) {
            add2follow(next, NT1, noNT);
            break;
          } else if (isNonTerminal(next, noRules)) {
            copyfollowfirst(NT1, next, noNT);
            if (isInFirSet(next, 'e', noNT)) {
              if (x == rules[j].num) {
                findfollow(rules[j].lhs, noRules, noNT);
                copyfollowfollow(NT1, rules[j].lhs, noNT);
              } else
                next = rules[j].rhs[x + 1];
            }
          }
          x++;
        }
      }
    }
  }
}
int main() {
  int gno = 0;
  int x = 0;
  char gramL;
  char gramR;
  printf("Enter the number of Productions ");
  scanf("%d", &gno);
  printf("Enter the Grammer\n");
  for (x = 0; x <gno; x++)
{
    printf("%d) ",x);
    scanf("\n%c", &rules[x].lhs);
    printf("->");
    scanf("%s", &rules[x].rhs);
    // strLength=strlen(rules[x].rhs);
    // strncpy(rules[0].rhs, "TD", 2);
}
  int i, j, k = 0;
  int noRules = 8;
  char NT, NT1, NT2;
  printf("Rules. . .\n");
  for (i = 0; i < noRules; i++) {
    printf("%c\t->\t", rules[i].lhs);
    for (j = 0; j < (rules[i].num) + 1; j++)
      printf("%c", rules[i].rhs[j]);
    printf("\t%d\n", rules[i].num);
  }
  // nonTerminal calc
  char arr[noRules];
  char ch;
  for (i = 0; i < noRules;) {
    ch = rules[i].lhs;
    if (!inarr(arr, ch, noRules))
      arr[k++] = ch;
    else if (inarr(arr, ch, noRules))
      i++;
  }
  printf("\n\n\n");
  for (i = 0; i < k; i++) {
    firsts[i].c = arr[i];
    follows[i].c = arr[i];
  }
  int index;
  noNT = k;
  char nonTerm[k];
  for (i = 0; i < k; i++)
    nonTerm[i] = arr[i];
  // term calc
  char term[40];
  k = 0;
  for (i = 0; i < noRules; i++) {
    int len;
    len = rules[i].num + 1;
    for (j = 0; j <= len; j++) {
      ch = rules[i].rhs[j];
      if (!isNonTerminal(ch, noRules)) {
        if ((!inarr(term, ch, noRules)) && ch != '\0' && ch != 'e') {
          term[k++] = ch;
        }
      }
    }
  }
  term[k++] = '$';
  noT = k;
  // printing non term and term. . .
  printf("Terminals are. . .\n");
  for (i = 0; i < noT; i++)
    printf("%c\t", term[i]);
  printf("\nNon-Terminals are. . .\n");
  for (i = 0; i < noNT; i++)
    printf("%c\t", nonTerm[i]);

  // first set calculation
  printf("\n\n");
  for (i = 0; i < noRules; i++) {
    char first = 0;
    char second = 0;
    first = rules[i].rhs[0];
    if (rules[i].num != 0)
      second = rules[i].rhs[1];
    if (!isNonTerminal(first, noRules)) {
      NT = rules[i].lhs;
      for (j = 0; j < noNT; j++)
        if (firsts[j].c == NT)
          break;
      if (!isInFirSet(NT, first, noNT)) {
        index = firsts[j].len;
        firsts[j].set[index] = first;
        firsts[j].len++;
      }
    }
  }
  /*printf("first set. . .\n");
  for(i=0;i<noNT;i++)
  {
          printf("%c\tlen=%d\t%s\n",firsts[i].c,firsts[i].len,firsts[i].set);
  }*/

  for (i = 0; i < noRules; i++) {
    char first = 0;
    char second = 0;
    first = rules[i].rhs[0];
    if (rules[i].num != 0)
      second = rules[i].rhs[1];
    if (isNonTerminal(first, noRules)) {
      NT1 = rules[i].lhs;
      add2first(NT1, noRules, noNT, rules[i].num, i);
      // printf("\n");
      // add2first(NT1,NT2,noRules,noNT);
    }
  }
  /*
  for(i=0;i<noRules;i++)
  {
          char first=0;
          first = rules[i].rhs[0];
          if(isNonTerminal(first,noRules))
          {
                  NT1 = rules[i].lhs;
                  NT2 = rules[i].rhs[0];
                  printf("\n");
                  add2first(NT1,NT2,noRules,noNT);
          }
  }*/
  printf("first set. . .\n");
  for (i = 0; i < noNT; i++) {
    printf("%c\tlen=%d\t%s\n", firsts[i].c, firsts[i].len, firsts[i].set);
  }
  // follow set calculation
  add2follow('$', follows[0].c, noNT);
  for (i = 0; i < noNT; i++) {
    NT1 = follows[i].c;
    findfollow(NT1, noRules, noNT);
    printf("\n");
  }
  printf("follow set. . .\n");
  for (i = 0; i < noNT; i++) {
    printf("%c\tlen=%d\t%s\n", follows[i].c, follows[i].len, follows[i].set);
  }
  // terminals
  printf("\n\n");

  // making table for predictive parsing
  int TABLE[noNT][noT];
  int Tind, NTind;
  for (i = 0; i < noNT; i++)
    for (j = 0; j < noT; j++)
      TABLE[i][j] = -1;
  for (i = 0; i < noRules; i++) {
    NT = rules[i].lhs;
    NT1 = rules[i].rhs[0];
    if (!isNonTerminal(NT1, noRules)) {
      Tind = charIndexT(NT1, term, noT);
      NTind = charIndexNT(NT, nonTerm, noT);
      // printf("\n%c(%d),%c(%d),i=%d",NT,NTind,NT1,Tind,i);
      if ((Tind != -1) && (NTind != -1))
        TABLE[NTind][Tind] = i;
      if (NT1 == 'e') {
        for (j = 0; j < noNT; j++)
          if (follows[j].c == NT)
            break;
        for (k = 0; k < follows[j].len; k++) {
          ch = follows[j].set[k];
          Tind = charIndexT(ch, term, noT);
          NTind = charIndexNT(NT, nonTerm, noT);
          // printf("\n%c,%c",NT,ch);
          if ((Tind != -1) && (NTind != -1) && (TABLE[NTind][Tind] == -1))
            TABLE[NTind][Tind] = i;
        }
      }
    } else if (isNonTerminal(NT1, noRules)) {
      for (j = 0; j < noNT; j++)
        if (firsts[j].c == NT1)
          break;
      // printf("\n>>%c\n",firsts[j].c);
      for (k = 0; k < firsts[j].len; k++) {
        ch = firsts[j].set[k];
        Tind = charIndexT(ch, term, noT);
        NTind = charIndexNT(NT, nonTerm, noT);
        // printf("\n%c,%c",NT,ch);
        if ((Tind != -1) && (NTind != -1))
          TABLE[NTind][Tind] = i;
      }
      if (isInFirSet(NT1, 'e', noNT)) {
        for (j = 0; j < noNT; j++)
          if (follows[j].c == NT)
            break;
        for (k = 0; k < follows[j].len; k++) {
          ch = follows[j].set[k];
          Tind = charIndexT(ch, term, noT);
          NTind = charIndexNT(NT, nonTerm, noT);
          // printf("\n%c,%c",NT,ch);
          if ((Tind != -1) && (NTind != -1) && (TABLE[NTind][Tind] == -1))
            TABLE[NTind][Tind] = i;
        }
      }
    }
  }
  printTable(TABLE, term, nonTerm);
  printf("\nRule numbers reference. . .\n");
  printf("Rule\tRule no.\n");
  for (i = 0; i < noRules; i++) {
    printf("%c->", rules[i].lhs);
    for (j = 0; j < (rules[i].num) + 1; j++)
      printf("%c", rules[i].rhs[j]);
    printf("\t%d\n", i);
  }
  printf("\n");
  // make parser
  for (i = 0; i < 20; i++) {
    STK[i] = '\0';
  }
  // printStack();
  char input[20];
  printf("\nEnter input to check:");
  scanf("%s", input);
  printf("\n");
  k = 0;
  char ip, stkTop, temp;
  int rule_no;
  int flag = 0;
  ip = input[k];
  push('E');
  printf("Stack \t\t\tCurrent Input symbol\n");
  while (1) {
    if (TOP == -1 && ip == '$') {
      printf("\nSuccessfully parsed!");
      break;
    } else if ((TOP == -1 && ip != '$')) {
      printf("\nInput not successfully parsed!");
      break;
    }
    stkTop = STK[TOP];
    if (ip == '$') {
      for (i = 0; i < noRules; i++) {
        if (rules[i].lhs == stkTop) {
          for (j = 0; j <= rules[i].num; j++) {
            if (rules[i].rhs[j] == 'e')
              flag = 1;
          }
        }
      }
      if (flag == 0) {
        printf("\nInput not successfully parsed!");
        break;
      }
    }
    if (stkTop == 'e') {
      pop();
    }
    if (isNonTerminal(stkTop, noRules)) {
      Tind = charIndexT(ip, term, noT);
      NTind = charIndexNT(stkTop, nonTerm, noT);
      if (TABLE[NTind][Tind] != -1) {
        rule_no = TABLE[NTind][Tind];
        pop();
      } else
        break;
      for (i = 0; i < noRules; i++)
        if (i == rule_no)
          break;
      for (j = rules[i].num; j >= 0; j--) {
        temp = rules[i].rhs[j];
        push(temp);
      }
    } else if (!isNonTerminal(stkTop, noRules)) {
      if (stkTop == ip) {
        pop();
        ip = input[++k];
      }
    }
    printf("\n%s\t\t\t\t\t%c", STK, ip);
  }

  printStack();
  printf("\n");
  return 0;
}
               </pre>
             </h5>
            </div>
          </div>
        </div>

        <!-- MDT and output of the macro -->
        <div class="accordion-item">
          <h2 class="accordion-header" id="headingNinth">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseNinth"
              aria-expanded="false"
              aria-controls="collapseNinth"
            >
              MDT and mecro output
            </button>
          </h2>
          <div
            id="collapseNinth"
            class="accordion-collapse collapse"
            aria-labelledby="headingNinth"
            data-bs-parent="#accordionExample"
          >
            <div class="accordion-body">
             <h5>
               <pre>
<!-- #include<stdio.h>
#include<conio.h>
#include<string.h> -->
 
struct mdt
{
    char lab[10];
    char opc[10];
    char oper[10];
}d[10];
 
void main()
{
    char label[10],opcode[10],operand[10],newlabel[10],newoperand[10];
    char macroname[10];
    int i,lines;
    FILE *f1,*f2,*f3;
    f1 = fopen("MACIN.txt","r");
    f2 = fopen("MACOUT.txt","w");
    f3 = fopen("MDT.txt","w");
    fscanf(f1,"%s %s %s",label,opcode,operand);
 
    while(strcmp(opcode,"END")!=0)
    {
        if(strcmp(opcode,"MACRO")==0)
        {
            strcpy(macroname,label);
            fscanf(f1,"%s%s%s",label,opcode,operand);
            lines = 0;
            while(strcmp(opcode,"MEND")!=0)
            {
                fprintf(f3,"%s\t%s\t%s\n",label,opcode,operand);
                strcpy(d[lines].lab,label);
                strcpy(d[lines].opc,opcode);
                strcpy(d[lines].oper,operand);
                fscanf(f1,"%s %s %s",label,opcode,operand);
                lines++;
            }
        }
        else if(strcmp(opcode,macroname)==0)
        {
            printf("lines=%d\n",lines);
            for(i=0;i<lines;i++)
            {
                fprintf(f2,"%s\t%s\t%s\n",d[i].lab,d[i].opc,d[i].oper);
                printf("DLAB=%s\nDOPC=%\nDOPER=%s\n",d[i].lab,d[i].opc,d[i].oper);
            }
        }
        else
        fprintf(f2,"%s\t%s\t%s\n",label,opcode,operand);
        fscanf(f1,"%s%s%s",label,opcode,operand);
    }
    fprintf(f2,"%s\t%s\t%s\n",label,opcode,operand);
    fclose(f1);
    fclose(f2);
    fclose(f3);
    printf("FINISHED");
    getch();
}

               </pre>
             </h5>
            </div>
          </div>
        </div>

        <!-- end -->
      </div>
    </div>

    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
      crossorigin="anonymous"
    ></script>
  </body>
</html>
